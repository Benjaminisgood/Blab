#!/usr/bin/env python3
"""Minimal OpenClaw-side client for Blab housekeeper runtime."""

import argparse
import json
import os
import sys
import time
import urllib.error
import urllib.request
import uuid
from typing import Any, Dict, Optional, Tuple


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Call Blab housekeeper runtime from local tooling.")
    parser.add_argument("--endpoint", default="http://127.0.0.1:48765", help="Runtime base URL.")
    parser.add_argument("--instruction", required=True, help="Natural-language task.")
    parser.add_argument("--actor-username", default="", help="Actor username for log ownership.")
    parser.add_argument("--plan-only", action="store_true", help="Only create plan, do not execute writes.")
    parser.add_argument(
        "--no-auto-repair",
        action="store_true",
        help="Disable one-shot automatic repair when execution has failed items.",
    )
    parser.add_argument("--request-id", default="", help="Custom request id; autogenerated when empty.")
    parser.add_argument("--idempotency-key", default="", help="Custom idempotency key; autogenerated when empty.")
    parser.add_argument("--token", default="", help="Bearer token, defaults to BLAB_HOUSEKEEPER_TOKEN.")
    parser.add_argument("--health-retries", type=int, default=3, help="Health-check retries before failing.")
    parser.add_argument("--health-timeout", type=float, default=2.5, help="Per health-check timeout (seconds).")
    parser.add_argument("--execute-timeout", type=float, default=120.0, help="Execute timeout (seconds).")
    parser.add_argument("--retry-delay", type=float, default=0.8, help="Delay between health retries (seconds).")
    return parser.parse_args()


def build_headers(token: str, idempotency_key: str, request_id: str) -> Dict[str, str]:
    headers = {
        "Content-Type": "application/json",
        "Idempotency-Key": idempotency_key,
        "X-Request-ID": request_id,
    }
    if token:
        headers["Authorization"] = f"Bearer {token}"
    return headers


def request_json(
    method: str,
    url: str,
    payload: Optional[Dict[str, Any]] = None,
    headers: Optional[Dict[str, str]] = None,
    timeout: float = 10.0,
) -> Tuple[int, str, Dict[str, str]]:
    body = None
    if payload is not None:
        body = json.dumps(payload, ensure_ascii=False).encode("utf-8")

    request = urllib.request.Request(url=url, data=body, method=method)
    for key, value in (headers or {}).items():
        request.add_header(key, value)

    try:
        with urllib.request.urlopen(request, timeout=timeout) as response:
            raw = response.read().decode("utf-8", errors="replace")
            return response.status, raw, dict(response.headers.items())
    except urllib.error.HTTPError as error:
        raw = error.read().decode("utf-8", errors="replace")
        return error.code, raw, dict(error.headers.items()) if error.headers else {}


def parse_json_or_none(raw: str) -> Optional[Dict[str, Any]]:
    try:
        data = json.loads(raw)
        return data if isinstance(data, dict) else None
    except json.JSONDecodeError:
        return None


def ensure_health(base_url: str, retries: int, timeout: float, delay: float) -> None:
    url = f"{base_url}/housekeeper/health"
    for attempt in range(1, retries + 1):
        try:
            status, raw, _ = request_json("GET", url, timeout=timeout)
            body = parse_json_or_none(raw)
            if status == 200 and body and body.get("ok") is True:
                return
        except Exception:
            pass

        if attempt < retries:
            time.sleep(delay)

    print("Health check failed: runtime is not ready.", file=sys.stderr)
    sys.exit(10)


def main() -> None:
    args = parse_args()

    base_url = args.endpoint.rstrip("/")
    token = args.token or os.environ.get("BLAB_HOUSEKEEPER_TOKEN", "")
    idempotency_key = args.idempotency_key or f"hk-{uuid.uuid4()}"
    request_id = args.request_id or f"hkreq-{uuid.uuid4()}"

    ensure_health(base_url, args.health_retries, args.health_timeout, args.retry_delay)

    payload: Dict[str, Any] = {
        "instruction": args.instruction,
        "autoExecute": not args.plan_only,
        "autoRepair": not args.no_auto_repair,
    }
    if args.actor_username.strip():
        payload["actorUsername"] = args.actor_username.strip()

    headers = build_headers(token, idempotency_key, request_id)
    status_code, raw_body, response_headers = request_json(
        "POST",
        f"{base_url}/housekeeper/execute",
        payload=payload,
        headers=headers,
        timeout=args.execute_timeout,
    )

    body = parse_json_or_none(raw_body)
    if body is None:
        print(raw_body)
    else:
        print(json.dumps(body, ensure_ascii=False, indent=2))

    replayed = response_headers.get("X-Idempotency-Replayed", "unknown")
    resolved_request_id = response_headers.get("X-Request-ID", request_id)
    print(
        f"request_id={resolved_request_id} idempotency_key={idempotency_key} replayed={replayed}",
        file=sys.stderr,
    )

    if status_code >= 400:
        sys.exit(20)

    if not body:
        sys.exit(0)

    status_text = str(body.get("status", ""))
    if status_text == "clarification_required":
        sys.exit(21)
    if status_text == "executed":
        execution = body.get("execution") or {}
        failure_count = int(execution.get("failureCount") or 0)
        if failure_count > 0:
            sys.exit(22)

    sys.exit(0)


if __name__ == "__main__":
    main()
